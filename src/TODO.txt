2010/03/21
* (Pending)Write a Builder to 
	+ construct concrete DatabaseInterface objects
	+ Using XML drivers to access Master Preference Table.

* (Pending)Design Master database table, purpose:
	+ store program's configurations
	+ store known databases' connection methods

* Virtual Destructors![done]

2010/03/22
* Program Architecture
	+ main function create Master object
	+ Create UI Layer accroding to Mater's preferences.
	+ (Required by UI Layer) Master object create database connection session
	+ UI Layer acqurie the pointer to Database object
	+ (Required by UI Layer) take actions, Using Database::*man().

2010/03/25
* Testcases
* Foundmentals
	+ [done]unistr:
		unistr::number
		unistr:unistr(char*);
	+ taglist_t
		[done]taglist_t::add_distinct;

2010/03/25
* Database::last_serial

2010/04/21
- System Configurations?
- Change Widget related to Database from Editor to Viewer [done@0501]
- Build bridges between UI and kernel, Considering MVC

2010/05/01
* Add merge to merge two tag groups
	- each group share the same tnode

2010/05/01
- A toolbar is needed for TabEdit [done@0502]
- Drag&Drop support, design binary layout for tag_t, tnode_t, etc.
- Consider TagEditor's implementation, inherit QAbstractItemView? Written a QWidget's subclass? [done@0502, QWidget's subclass]
- SQL generator for Edit actions, that also means we must log actions. Action Pattern should be used. [withdrawed@0502, see 0502-01]

2010/05/02
- (0502-01) Design unified "New/Update" action process for TagEdit. 
- Write another layer beyond ***Man class, for undo/redo support
	- log sql sentences is enough
	- don't use transactions as we want all sql lang don't send to sql layer until saves
		+ However, a problem: non-relative modification


2010/05/08
* Impl. all tag_edit_action's subclass and theirs factory methods [done]
* adjust code to remove "primary name" [done@09]
* add icon to actions in gui [done@09]
* add load data to gui [part]
* add model to viewer.
	- tag search result model. [done]
	- alias model.
* test undo/redo, db rollback
* MIME type and kernel object's binary layout
* we may need a exception model ...

2010/05/09
* enhance tag search result model
	- fix a small bug for showing mastername [done@20, TagMan.cpp, mistake judgement on no tnode tag]
* adjust GUI [pending]
	- easier to use and understand
		+ passed, need future design [@20]
	- current design is too narrow to use
		+ remove one tageditor [@20]
		+ future optimization is needed
* enhance load data to gui function [pending@20]
	- extensible
* fix bugs in TagEditContext and TagEdit
	- many bugs, such as dumplicated triggered signals
		+ fix: forgot to clear undo stack after commit changes
		+ fix: redo-undo's intraction with ui
		+ fix: focus issue, making it easier to switch LineEdit's undo-redo and TagEdit's undo-redo
* test undo/redo, db rollback [delayed]
	- foundation to next work
* MIME type and kernel object's binary layout [done@20]
	- foundation of drag&drop
		- drag&drop is the base of facility of alias and tagging
* merging's implementation. [delayed]
* add model to alias viewer [delayed]

2010/05/20
* enhance load data to gui function
	- extensible
* test undo/redo, db rollback
	- foundation to next work
		+ fix: comment edition [done@22]
	- problem: test what?
		+ no merge, no test..
* merging's implementation. [removed@22]
* add model to alias viewer
* Drag&Drop Support

2010/05/22
* Writing GUI's usecase!
	- f**k I can't coding because GUI's usecases are always changing!
* Redesign TagManContext
* As UI redesigned, following function shall be changed:
	- chpname shall be removed
	- alias shall be enhanced to meet GUI's model part's need
	- more predicted change protocol
	- Redo/Undo System shall be improved, dumplicated SQL executions can't be dimissed in current design.

2010/06/27
下一步目标：
[kernel]编写tag之间tag的功能
	- written @ 07/18, untested
	- testcase written @ 07/20, compile passed but still untested
[kernel]编写基于tagging搜索的功能，加入部分搜索功能
	ps：SQLITE竟然支持REGEXP！
[gui]编写alias的添加删除界面
[gui]使用diff代替步进操作的undo/redo
[gui]分离各个编辑窗口的undo/redo功能，善用GUI Widget自己提供的Undo/Redo来降低编程复杂度
	- 已经将TagEditContext从kernel项目中移除，下一步是将其从版本库中移除。
[gui]采用编辑|查找|查看的分栏方式
[gui]编写tag tag的功能
[gui]drag drop支持
	- pending, 作为一个preview/alpha这还太高级了
	- 作为更高级的tagtag UI，在之后的版本实现
[kernel] 编写Attribute
[kernel] 确定文件对象的结构――也即此程序认识资源的方法。
	- considerations:
		+ 此结构是否需要对文件系统有更深的认识？例如识别inode？
		+ 记录HASH值是必须有的特性，不过这个计算是不是消耗大了点……并且这需要依赖库cryptopp
			* 准备研究cryptopp的文档
		+ 一个关键问题是如何管理“文件”和“资源”之间的关系
			* 对于解包的EAC来说，必然出现一组文件才代表一个资源的问题
			* 另一个问题则是由分卷压缩包造成的。
		+ 另一个关键问题在于如何设计“Collector”，或者“容器”这个概念。
			* 容器，是接受一类tag的目录
		+ 还有一个关键是与系统其他部分的整合，很多管理任务用TC、甚至双Explorer都能做的很好
			* 监视系统变更是不可避免的
	- design:
		+ 3 level
		+ bottom: file
			* 最基本的单元，提供基础的文件访问功能
		+ medium: resource
			* 本系统处理的原子对象，可以是文件，也可以是目录及其中的所有文件系统对象(recursive)
			* 判定resource的原则为
				- 相比directory其中的对象不会再提供更多的tag
				- 其中的对象提供的tag本质相同，如一个“Futakoi Alternative”目录的所有文件都只有KTXP和Futakoi_Alternative两个tag
					+ 有些人（如书店）喜欢把某个话题（如SisterPricess）的所有相关资源都堆在一个目录中
					+ 需要提供accidental的tag，用来标识次要的tag，使其不影响resource组合算法
					+ 不过最给力的应该还是手动处理划分的方法了吧……
				- attribute不受影响
			* 这样做的好处：
				- 排除“卷”（单行本）属性的影响
				- 结果与automatic tagger息息相关
				- UI中要提供打散文件夹resource的功能
				- 不支持嵌套资源，提供将误放入一个resource文件夹的另一个resource提出的功能
			* 可以为resource打tag
			* 注意：没有resource-file这个relation，resource-file的关系由文件系统维护
			* file仅是为校验功能而存在的
		+ top: container
			* 资源的集合
			* container可以嵌套
			* container分为可写和不可写的
				- 可写container可以接受资源，可以移出资源
				- 只读container只能从中复制资源
			* container分为几种：
				- source，可以是ro，也可以是rw的，系统不会往其中放入resource
				- cart，source到collector的中转站，存放下载后暂时不要归类的文件（如新番，都直接归类了找个毛啊）
				- collector，rw，系统不会从中挪出resource
	- structure for file:
		+ unistr filename――文件名，使用unistr保持跨平台性，注意超长（256+）路径的处理
		+ last modification date――精确到秒以保证可移植性
		+ CRC32/sha-1/256/384/...checksum
		+ RFID，Registered File ID, 注册文件编号
	- 工作的scenario 1: 自动分类
		+ auto tagger为source container中的文件打tag
		+ 在tagging的过程中，系统将综合出resource，加入到resource系统中
		+ 执行masker，排除暂时不需要（或者无法）归类的资源。
		+ 遍历collector，执行acceptor确定每个resource应该在的位置
		+ 将resource放入对应的collector中
	- Scenario 2: 资源查找
		+ 给出几个tag名
		+ 查找出相关度最大的一批tnode
		+ 用tnode定位资源
	- Scenario 3:自动重命名
		+ 以tag来为资源重命名，注意，若资源名已经提供了足够的tag，那么就不需要这么做
[kernel] 文件对象结构的重新理解
	- resource
		* 结构：
			+ rid
			+ 路径
			+ last modification date
	- file
		* 结构
			+ rfid
			+ belong resource, reference resource(rid)
			+ path（相对于resource）
			+ type: dir/file
			+ last modification date
			+ optional: HASH nullable
	- container

2010/08/25
[kernel] 文件系统的再次理解
	分为几张表：
	+ fso pool，存储文件系统对象，表示目录和文件
		fsoid, parentid, name, size, fs date, cascade date, hash algo, hash.
		操作：
		- add(path, flag{RECURSIVE,...})
		- move(fsoid, pathnew) ( call chroot internally )
		- cp (fsoid, pathnew ) ( call add(pathnew, RECURSIVE) internally )
		- chroot(fsoid, newpath)
		- del(fsoid, flag{RECURSIVE,...})
	+ tag relation，表示对文件系统对象的tag
		tnode, fsoid
		操作：
		- 大家都懂的
	+ 各个fs相关的子系统有各自的id，有一张共同的表储存这些每个fssubsys关心的fsoid
		fssubsysid, fsoid
		fssubsysid, name, type, loadinginfo, prio, deps(这两个设计是用来解决先后关系的，不能没有tag就classify）, comment
		- 以此支持python
		例如检查更新就是一个fssubsys，监视一定数量的fso，并将更新写回fso pool
		自动归档是另一个fssubsys
	+ 下面就是fs子系统的设计了，如何设计出一个flexible的子系统，并且还要加上python支持？

[TODO] 基本定下来了，先写fso pool吧
2010/08/28
FSO Pool完成，未测试
不过需要一个工具(utility)来查看已经被归档的文件，不然没法继续测试
另外需要与文件系统同步的模块。
FS同步默认不是自动的，换句话说在默认情况下FS的变更不会反应到数据库中。
除非手动要求更新。

更新模块独立出去，另外要考虑多个更新数据源（inotify，NTFS-Journal，ReadDirectoryChangesW）
还要考虑删除不存在的对象

2010/09/04
定一下Interface好了――失败了

先写ModSource，然后才能写Utility
auto-tagger的hook
auto-classifier的working queue.

2010/09/09
ModSource完成，不过需要完成以下系统
+ 一个AsyncWQ实现，负责管理工作队列
+ 一个工作对象，dry run
#+ 负责从db虚拟的文件系统中读取数据，dry run，最后

设计失误，这里似乎没法单独测试这些东西

那么就用shell测试一下FsodbMan的可用性吧，反正迭代执行添加删除的代码我也没写……

cd(写了）
ls(代码已经写了，但是没写printfso)
touch(::add，没mkdir)
rm(不区分dir和file，直接用rm即可）(::rm还没写……）

2010/09/12
shell代码只剩printfso了

2010/10/20
娘的拖了一个多月！架构都快忘干净个屁了！
还有09/12谁tm说代码只剩printfso了？缺他妈那么大一块，编译都编译不动玩屁啊！
/dal
	: database abstraction layer
		all real db opeartions here
/kernel
	: UI indepedent codes, contains
		+ db objects (tag, tnode, fso_t)
		+ db table managers (TagMan, TnodeMan, RelationMan, FsodbMan)
		+ db utilities (sql_stmt)
		+ db center (Database)
		+ Advanced Interface (ModSource)
			- Managers don't edit table directly
			- #####TODO##### 将ModSource作为变更管理模块，应该从低级任务（相对于ModSource）中抽出，应该是如下的设计：
				        UI -> High Level File System snapshottor -> FsodbMan -> Snapshot in Database
				Plugin1- ModSource --/
				Plugin2/
				...
			- 改名为snapshotter，不过问题又来了：hashing咋办？（delayed，从obligation上来讲由snapshotter来做更好）
		+ Kernel threads
			- Working on time-cost jobs
				* hashing, copying, moving, indexing
			- Nearly all have relation with plugins
				* note! copying and moving are platform depedent, placed in plugin may reduce the pal
			- 需要Transaction支持的工作要扔这里，例如move，得move完了才能改数据库
			- 暂时先不写
		+ plugins (/plugin)
			- 插件系统是个很烦的东西
			- pal负责module的load,unload还有getfunc是不容置疑的
			- 但是其他部分就很烦了，要不要写个插件类？
				* 似乎是必要的，毕竟手动维护实在太麻烦了
				* 得，又得部分重构
			- 要定下一个module规范，免得写到后来到处是module到处是loader
				* 考虑各种可能的插件，以及他们之间的最小公共集
			- 需要一个基类负责module loader and applyer的所有工作。
			- 先把ModSource分离出来再说，现在这个架势啥都搞不好……
/gui
	: 反正要推倒重来，随便了
/pal
	: Platform Abstraction Layer
		+ Unicode Support :wchar_t under windows and char(UTF-8) under *nix.
		+ Module Support

要让系统工作起来该如何办？
要尽早测试就要先分离ModSource和其中的插件部分，并且尽量隔离插件部分
不编译插件部分是最好的选择

另外考虑转向cmake

2010/10/21
考虑过后snapshotter只负责添加，文件系统操作的活不应该由它干
删除rm、mv和cp等费事而又和数据库无关的操作
需要新增管理fs op的类，不过很好，这样就可以更快的开始测试了。

2010/10/24
妈的2了，shell根本不需要snapshotter什么的支持，不编译进去就完事了！
文件系统操作需要转调snapshotter或者fsodbman来处理
另外不能依赖fswatcher来实现copy/mv/cp的追踪，因为ReadDirectoryChangesW似乎只处理一个目录……
	fsnotify虽强不过……
modinoti改名fsnotify，规范化，并修改了workflow

2010/10/28
fsodbman tested (@yesterday, forgot to log)
roadmap:
	snapshotter
		- need a pal module to abstract platform depedent fs operations
		- like VFS, use common attributes of various FS
		- load into structure fso directly, so it need to include
		  "../kernel/fso.h"
		- but afterall I've made a usable snapshotter beforce use pal module...
	shell-ext (add snapshotter related commands and add a chenv op to switch operating environment)
	file-tagger
	plugin-base
	plugin-subsys-fswatcher
	plugin-subsys-fswatcher-ntfs
	daemon-ntfs
	plugin-subsys-autotagger
	plugin-subsys-autotagger-animestd
	async-tasklet-base (atasklet)
	async-tasklet-autonewtag

after kernel done:
	name formatting (names like TagMan should be changed to tag_man)

async-tasklet:
	base class for asynchronized processing routine.
	used in:
		- processes which take long time.
		- processes which needs users' input

		However, these two types of processing need another sub-classes of the base class.
	request:
		safe and fast copy like POD types

2010/11/29
	focus on shell
	but make it easily...

	F**K Qt! QtDir WON'T reture then driver letter!
MUST WRITE a VFS module

	test passed, commit to the repo.
